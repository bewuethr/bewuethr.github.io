---
published: false
title: "What's new in C++11?"
layout: post
---

I'm currently reading Stroustrup's [A Tour of C++](http://www.stroustrup.com/Tour.html) to get to know what's new in C++11. There are tons of great articles and whole books about the topic "What's new in C++11?"; to reinforce my learning, I'll create yet another list here. Some of these these might just be new to me and not to C++.

Also, this is in *no way* meant to be a complete description. Think of it as "mentions"; I'll link to articles I found especially helpful when researching a topic further.

### Declaring and initializing variables (uniform initialization and initializer lists)

I'm used to initializing variables like this:

```cpp
double d = 1.23;
```

A new syntax allows for this:

```cpp
double d {1.23};	// or double d = {1.23}, the = is optional
```

which has the advantage of preventing narrowing conversions.

```cpp
int i {1.2};	// won't compile
```

Initializer lists allow to initialize standard library containers and structs just like C arrays:

```cpp
vector<int> v {1, 2, 3, 4, 5};
Point p {1,2};	// for a struct Point with two int members
```

Helpful links:

* [Is C++11 Uniform Initialization a replacement for the old style syntax?](http://programmers.stackexchange.com/questions/133688/is-c11-uniform-initialization-a-replacement-for-the-old-style-syntax) on Programmers Stack Exchange
* [What are the differences between c-like, constructor, and uniform initialization?](http://stackoverflow.com/questions/24953658/what-are-the-differences-between-c-like-constructor-and-uniform-initialization) on Stack Overflow

### Type deduction

When declaring a variable, its type can be deduced from the initializer:

```cpp
auto i = 10;	// i is an int
```

When to use `auto` is heavily discussed; an often quoted resource about the topic is Herb Sutter's article [Almost Always Auto](http://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/).

### Marking expressions as constant

In addition to the `const` keyword ("I promise not to change this value"), C++11 introduces `constexpr` ("to be evaluated at compile time"). Functions used in constant expressions must be defined `constexpr` themselves and meet a few criteria:

```cpp
constexpr double square(double x) { return x*x; }
```

Helpful link: [Difference between `constexpr` and `const`](http://stackoverflow.com/questions/14116003/difference-between-constexpr-and-const) on Stack Overflow

Note: this is not supported in Visual Studio 2013.

### Range-`for`-statements

To traverse a sequence, a new, simpler syntax is introduced:

```cpp
vector<int> v = {1, 2, 3, 4, 5};
for (const auto& x : v)	// for each x in v
	cout << x << '\n';
```

When to use `auto x`, `auto& x` or `const auto& x` is discussed in this Stack Overflow question: [C++11 range based loop: get item by value or reference to const](http://stackoverflow.com/questions/15176104/c11-range-based-loop-get-item-by-value-or-reference-to-const)

### A value for the null pointer

Instead of using `NULL` or `0` for the null pointer, there is now the value `nullptr`. Testing a pointer value is equivalent to comparing it to `nullptr`: `if (p)` is equivalent to `if (p!=nullptr)`.


### Strongly typed enumerations

Enumerators used to have the same scope as their surrounding structure. With C++11, you can have scoped enumerators by using `enum class`es:

```cpp
enum class Color { red, blue green };
Color col = Color::red;
```

The enumerators (such as `red`) are in the scope of their `enum class`.

### Static assertions

Similar to `assert` in C, you can use `static_assert` (but for compile time checks): `static_assert(A,S)` prints `S` as a compiler message if `A` is not true.

### Explicit overriding

If a function is declared `virtual` in a base class, it is overridden by a function in a derived class with the same signature. To make this clear also for large hierarchies, the overriding function can be explicitly marked as overriding:

```cpp
void draw() const override;	// overrides virtual draw() in the base class
```

